NAME: timescaledb
LAST DEPLOYED: Mon Apr 18 14:39:00 2022
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
HOOKS:
---
# Source: timescaledb-single/templates/job-update-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: batch/v1
kind: Job
metadata:
  name: "timescaledb-patroni-ii"
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
  annotations:
    "helm.sh/hook": post-upgrade
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  activeDeadlineSeconds: 120
  template:
    metadata:
      labels:
        app: timescaledb
        chart: timescaledb-single-0.11.0
        release: timescaledb
        heritage: Helm
    spec:
      restartPolicy: OnFailure
      containers:
      - name: timescaledb-patch-patroni-config
        image: curlimages/curl
        command: ["/bin/sh"]
        # Patching the Patroni configuration is good, however it should not block an upgrade from going through
        # Therefore we ensure we always exit with an exitcode 0, so that Helm is satisfied with this upgrade job
        args:
        - '-c'
        - |
          /usr/bin/curl --connect-timeout 30 --include --request PATCH --data \
          "{\"loop_wait\":10,\"maximum_lag_on_failover\":33554432,\"postgresql\":{\"parameters\":{\"archive_command\":\"/etc/timescaledb/scripts/pgbackrest_archive.sh %p\",\"archive_mode\":\"on\",\"archive_timeout\":\"1800s\",\"autovacuum_analyze_scale_factor\":0.02,\"autovacuum_max_workers\":10,\"autovacuum_naptime\":\"5s\",\"autovacuum_vacuum_cost_limit\":500,\"autovacuum_vacuum_scale_factor\":0.05,\"hot_standby\":\"on\",\"log_autovacuum_min_duration\":\"1min\",\"log_checkpoints\":\"on\",\"log_connections\":\"on\",\"log_disconnections\":\"on\",\"log_line_prefix\":\"%t [%p]: [%c-%l] %u@%d,app=%a [%e] \",\"log_lock_waits\":\"on\",\"log_min_duration_statement\":\"1s\",\"log_statement\":\"ddl\",\"max_connections\":100,\"max_prepared_transactions\":150,\"shared_preload_libraries\":\"timescaledb,pg_stat_statements\",\"ssl\":\"on\",\"ssl_cert_file\":\"/etc/certificate/tls.crt\",\"ssl_key_file\":\"/etc/certificate/tls.key\",\"tcp_keepalives_idle\":900,\"tcp_keepalives_interval\":100,\"temp_file_limit\":\"1GB\",\"timescaledb.passfile\":\"../.pgpass\",\"unix_socket_directories\":\"/var/run/postgresql\",\"unix_socket_permissions\":\"0750\",\"wal_level\":\"hot_standby\",\"wal_log_hints\":\"on\"},\"use_pg_rewind\":true,\"use_slots\":true},\"retry_timeout\":10,\"ttl\":30}" \
          "http://timescaledb-config:8008/config"
          exit 0
MANIFEST:
---
# Source: timescaledb-single/templates/serviceaccount-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: ServiceAccount
metadata:
  name: timescaledb
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
---
# Source: timescaledb-single/templates/secret-certificate.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: timescaledb-certificate
  labels:
    app: timescaledb
    cluster-name: timescaledb
type: kubernetes.io/tls
stringData:
  tls.crt: "-----BEGIN CERTIFICATE-----\nMIIDFzCCAf+gAwIBAgIQHQiyxMg8rCVNDMo3i1Rn/DANBgkqhkiG9w0BAQsFADAW\nMRQwEgYDVQQDEwt0aW1lc2NhbGVkYjAeFw0yMjA0MTgxODM5MDBaFw0yNzA0MTgx\nODM5MDBaMBYxFDASBgNVBAMTC3RpbWVzY2FsZWRiMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAt1gzSD9vmkTzAuwCbiUP1jD8ICPy4Hu3Nsnykr3osURN\nap1XJHu+KliQBHLKZ/7ECVtSdrZHSAggqdLRlxEiaCXW39W/Uoxe+DWjB5jOz/6k\nzYGjqnEfxPgucc+lP5cPT23SR+/9ZL8hXr7i7xiLZFmrVfT4KagdIVo6b4o1t8S9\nV/AAL0Tb21m5jUWkC5yebWPnhCnRSzeV13TQafkxjaUYN7x+pJ6euj3LTgLPL4ki\nwK+S14mZ1US8sr5ZBEQD0Eze0I6JD+FFwpP6Mixci5dWQur3zpo20VQFFKiCb9j/\naRfuhN0sOQoapCt0S6OfeD5AcjPia8D+X4P9fMp74wIDAQABo2EwXzAOBgNVHQ8B\nAf8EBAMCAqQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMA8GA1UdEwEB\n/wQFMAMBAf8wHQYDVR0OBBYEFO4+zbhdq1MmM0OsH+ekKC45mMwmMA0GCSqGSIb3\nDQEBCwUAA4IBAQAGVGwUcHLzJ+6McqXkUwU6G4Cs2VrkvNIH3jcOfV2+IGK1DTWn\nnXkdqJndFWRv/Xg69hAZA5DPlLLLvgL5MT5SgQR8vkWfZpBDWEpCSf5JObWt70P2\ngLBHWSgLOLXEbOu4TFl/Tl+cX8jB6YZXIJYF3zN7Sv1h2VwnHQJ6NguIBxPJ9O4O\ntaisZL/cE+s27wmiwVvNq7UzyzdhKEAb8gF2AOCXJOS3GEk6SS9cVDiw2Mpy8Jgn\nBAPw49JXL/axQX9yI2bupmv45h561ZnQi798OV1/JcS6RR6qye7Ut4Lfjdhrfx9H\nvY4keu5tjpw2IYLQiDlgsmcS+DM371nGScBw\n-----END CERTIFICATE-----\n"
  tls.key: "-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAt1gzSD9vmkTzAuwCbiUP1jD8ICPy4Hu3Nsnykr3osURNap1X\nJHu+KliQBHLKZ/7ECVtSdrZHSAggqdLRlxEiaCXW39W/Uoxe+DWjB5jOz/6kzYGj\nqnEfxPgucc+lP5cPT23SR+/9ZL8hXr7i7xiLZFmrVfT4KagdIVo6b4o1t8S9V/AA\nL0Tb21m5jUWkC5yebWPnhCnRSzeV13TQafkxjaUYN7x+pJ6euj3LTgLPL4kiwK+S\n14mZ1US8sr5ZBEQD0Eze0I6JD+FFwpP6Mixci5dWQur3zpo20VQFFKiCb9j/aRfu\nhN0sOQoapCt0S6OfeD5AcjPia8D+X4P9fMp74wIDAQABAoIBACKR0dGMjHl1CLED\nWQ31lP/Y6qEQxinHiesdtswuXKKX81Tn59dsMZYAbt832aw0IDh3bJwPkG8ngSkk\nI/qs82TZxaMcxV9GMl3wlxXGnTAgnmhVSkvH2qqj9PXmpgzQacWbOmvv90I4u40G\nxvk4EohQU/r4HpaUKTHxtlTzpV9JugMCrmOajd+zxugZQb1MBkVM21OPd1MjZBvD\n9BjTQ2EAMqEk9gubcoxsbYc80d/UgQ122yAoTAJBukGPKx4oQPRpWEFTIYbrjpcK\nzHC9hxSnfhkYi/4Z/u7+Aa5mH2VO3WmPGVfMCgZ9L7kjQR8lGtmWLJbppV9AD2jH\nInePXUECgYEAwVLx6dv5+Ab5OvJI1R74E57S/+wkxBMfIb6WEAHMV7AtdVoodMJN\nVg4t0Zepe81oYeCOJBf0jtK6RHMpL/bdrz3uBx8e1SdoDkIedV6DOAem0Zs3Z15h\ndObQAsYb6BLI8OhbYjL7/L5EcgzAN7mEIxipM3bpvnjraL1bEtbeyYMCgYEA8skA\noIsVqHhWqX4ARXnwBfEpKWHj+A32iN+A4r1V2INWH62rF7thS34Hm1UjNekHeynX\n9TjfGlQ7xqK0aIXCADLGqZAtc+7U9jsXKeOCh6R5W+8ZfXK6jHy3f13yLsVt+P1m\nnbQcmwK2cqiNZMDltMrKzsRCp9sauWTzVly11iECgYAxsvEd/b81VBWeYcr3fw6n\nfJ0hzcNl5MSMGELbupqdsFz/Xj4oRgs7pEmDKEoZ2aSMBP6FqOLmFKZuEmz0N7Kl\n6nXWvtleUtMdV0IdSj7RmKX6HL0RheHn+65eCDAEaU/fHtzfUdwWDZPq/fwsVzTx\nENXutRNCNDPQqV1Qaoy7oQKBgCcI7EHjutq4Zm6f5JlHDrFV4eFWbNnQHOhKzyUl\nfezuyOUU/iI1rWH+5Gg0GxIq4loKEz/JIg3Qpz+7nzgC8XsorspKdRRjvPfN7l58\nxtraNezzF20VCitWTgZ7a1nbwl+7Fkma0NKXcBAlS358iTI1PMBby7/DOZu/QGSN\nSWshAoGBALa2LlfqL71ZrM0cJByDreMhyEwuRdZvwal1WjNN4g1RQ8D5UjB+/jyk\nl6vM8AAb7YpMlXOyy/BZnecIt1Riy6TWxM3BcK0NWDGUKiNu8t3cs4g/+h3pNDqS\nCDLd+R2K9pvDZam/Qgwd41Ku6wT/ILaR9pseDzLG6w1vLRc169dB\n-----END RSA PRIVATE KEY-----\n"
...
---
# Source: timescaledb-single/templates/secret-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: "timescaledb-credentials"
  labels:
    app: timescaledb
    cluster-name: timescaledb
type: Opaque
stringData:
  PATRONI_SUPERUSER_PASSWORD: "FJ9y5czVtUZnp5zP"
  PATRONI_REPLICATION_PASSWORD: "rQrfoC7DXxC07ZyI"
  PATRONI_admin_PASSWORD: "Da4PqR68qEgke8d7"
...
---
# Source: timescaledb-single/templates/secret-pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: v1
kind: Secret
metadata:
  name: "timescaledb-pgbackrest"
  labels:
    app: timescaledb
    cluster-name: timescaledb
type: Opaque
stringData:
  PGBACKREST_REPO1_S3_BUCKET: ""
  PGBACKREST_REPO1_S3_ENDPOINT: s3.amazonaws.com
  PGBACKREST_REPO1_S3_KEY: ""
  PGBACKREST_REPO1_S3_KEY_SECRET: ""
  PGBACKREST_REPO1_S3_REGION: ""
...
---
# Source: timescaledb-single/templates/configmap-patroni.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.---
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-patroni
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
data:
  patroni.yaml: |
    bootstrap:
      dcs:
        loop_wait: 10
        maximum_lag_on_failover: 33554432
        postgresql:
          parameters:
            archive_command: /etc/timescaledb/scripts/pgbackrest_archive.sh %p
            archive_mode: "on"
            archive_timeout: 1800s
            autovacuum_analyze_scale_factor: 0.02
            autovacuum_max_workers: 10
            autovacuum_naptime: 5s
            autovacuum_vacuum_cost_limit: 500
            autovacuum_vacuum_scale_factor: 0.05
            hot_standby: "on"
            log_autovacuum_min_duration: 1min
            log_checkpoints: "on"
            log_connections: "on"
            log_disconnections: "on"
            log_line_prefix: '%t [%p]: [%c-%l] %u@%d,app=%a [%e] '
            log_lock_waits: "on"
            log_min_duration_statement: 1s
            log_statement: ddl
            max_connections: 100
            max_prepared_transactions: 150
            shared_preload_libraries: timescaledb,pg_stat_statements
            ssl: "on"
            ssl_cert_file: /etc/certificate/tls.crt
            ssl_key_file: /etc/certificate/tls.key
            tcp_keepalives_idle: 900
            tcp_keepalives_interval: 100
            temp_file_limit: 1GB
            timescaledb.passfile: ../.pgpass
            unix_socket_directories: /var/run/postgresql
            unix_socket_permissions: "0750"
            wal_level: hot_standby
            wal_log_hints: "on"
          use_pg_rewind: true
          use_slots: true
        retry_timeout: 10
        ttl: 30
      method: restore_or_initdb
      post_init: /etc/timescaledb/scripts/post_init.sh
      restore_or_initdb:
        command: |
          /etc/timescaledb/scripts/restore_or_initdb.sh --encoding=UTF8 --locale=C.UTF-8
        keep_existing_recovery_conf: true
    kubernetes:
      role_label: role
      scope_label: cluster-name
      use_endpoints: true
    log:
      level: WARNING
    postgresql:
      authentication:
        replication:
          username: standby
        superuser:
          username: postgres
      basebackup:
      - waldir: /var/lib/postgresql/wal/pg_wal
      callbacks:
        on_reload: /etc/timescaledb/scripts/patroni_callback.sh
        on_restart: /etc/timescaledb/scripts/patroni_callback.sh
        on_role_change: /etc/timescaledb/scripts/patroni_callback.sh
        on_start: /etc/timescaledb/scripts/patroni_callback.sh
        on_stop: /etc/timescaledb/scripts/patroni_callback.sh
      create_replica_methods:
      - pgbackrest
      - basebackup
      listen: 0.0.0.0:5432
      pg_hba:
      - local     all             postgres                              peer
      - local     all             all                                   md5
      - hostnossl all,replication all                all                reject
      - hostssl   all             all                127.0.0.1/32       md5
      - hostssl   all             all                ::1/128            md5
      - hostssl   replication     standby            all                md5
      - hostssl   all             all                all                md5
      pgbackrest:
        command: /etc/timescaledb/scripts/pgbackrest_restore.sh
        keep_data: true
        no_master: true
        no_params: true
      recovery_conf:
        restore_command: /etc/timescaledb/scripts/pgbackrest_archive_get.sh %f "%p"
      use_unix_socket: true
    restapi:
      listen: 0.0.0.0:8008
...
---
# Source: timescaledb-single/templates/configmap-pgbackrest.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-pgbackrest
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
data:
  pgbackrest.conf: |
    [global]
    compress-level=3
    compress-type=lz4
    process-max=4
    repo1-cipher-type=none
    repo1-path=/default/timescaledb/
    repo1-retention-diff=2
    repo1-retention-full=2
    repo1-s3-endpoint=s3.amazonaws.com
    repo1-s3-region=us-east-2
    repo1-type=s3
    spool-path=/var/run/postgresql
    start-fast=y

    [poddb]
    pg1-port=5432
    pg1-host-user=postgres
    pg1-path=/var/lib/postgresql/data
    pg1-socket-path=/var/run/postgresql

    link-all=y

    [global:archive-push]

    [global:archive-get]
...
---
# Source: timescaledb-single/templates/configmap-scripts.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.---
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-scripts
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
data:
  # If no backup is configured, archive_command would normally fail. A failing archive_command on a cluster
  # is going to cause WAL to be kept around forever, meaning we'll fill up Volumes we have quite quickly.
  #
  # Therefore, if the backup is disabled, we always return exitcode 0 when archiving
  pgbackrest_archive.sh: |
    #!/bin/sh

    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - archive - $1"
    }

    [ -z "$1" ] && log "Usage: $0 <WALFILE or DIRECTORY>" && exit 1

    PGBACKREST_BACKUP_ENABLED=0
    [ ${PGBACKREST_BACKUP_ENABLED} -ne 0 ] || exit 0

    . "${HOME}/.pgbackrest_environment"
    exec pgbackrest --stanza=poddb archive-push "$@"
  pgbackrest_archive_get.sh: |
    #!/bin/sh
    PGBACKREST_BACKUP_ENABLED=0
    [ ${PGBACKREST_BACKUP_ENABLED} -ne 0 ] || exit 0

    . "${HOME}/.pgbackrest_environment"
    exec pgbackrest --stanza=poddb archive-get "${1}" "${2}"
  pgbackrest_bootstrap.sh: |
    #!/bin/sh
    set -e

    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - bootstrap - $1"
    }

    terminate() {
        log "Stopping"
        exit 1
    }
    # If we don't catch these signals, and we're still waiting for PostgreSQL
    # to be ready, we will not respond at all to a regular shutdown request,
    # therefore, we explicitly terminate if we receive these signals.
    trap terminate TERM QUIT

    while ! pg_isready -q; do
        log "Waiting for PostgreSQL to become available"
        sleep 3
    done

    # We'll be lazy; we wait for another while to allow the database to promote
    # to primary if it's the only one running
    sleep 10

    # If we are the primary, we want to create/validate the backup stanza
    if [ "$(psql -c "SELECT pg_is_in_recovery()::text" -AtXq)" = "false" ]; then
        pgbackrest check || {
            log "Creating pgBackrest stanza"
            pgbackrest --stanza=poddb stanza-create --log-level-stderr=info || exit 1
            log "Creating initial backup"
            pgbackrest --type=full backup || exit 1
        }
    fi

    log "Starting pgBackrest api to listen for backup requests"
    exec python3 /scripts/pgbackrest-rest.py --stanza=poddb --loglevel=debug
  pgbackrest_restore.sh: |
    #!/bin/sh
    PGBACKREST_BACKUP_ENABLED=0
    [ ${PGBACKREST_BACKUP_ENABLED} -ne 0 ] || exit 1

    . "${HOME}/.pod_environment"

    PGDATA="/var/lib/postgresql/data"
    WALDIR="/var/lib/postgresql/wal/pg_wal"

    # A missing PGDATA points to Patroni removing a botched PGDATA, or manual
    # intervention. In this scenario, we need to recreate the DATA and WALDIRs
    # to keep pgBackRest happy
    [ -d "${PGDATA}" ] || install -o postgres -g postgres -d -m 0700 "${PGDATA}"
    [ -d "${WALDIR}" ] || install -o postgres -g postgres -d -m 0700 "${WALDIR}"

    exec pgbackrest --force --delta --log-level-console=detail restore
  restore_or_initdb.sh: |
    #!/bin/sh

    . "${HOME}/.pod_environment"

    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - restore_or_initdb - $1"
    }

    PGDATA="/var/lib/postgresql/data"
    WALDIR="/var/lib/postgresql/wal/pg_wal"
    # A missing PGDATA points to Patroni removing a botched PGDATA, or manual
    # intervention. In this scenario, we need to recreate the DATA and WALDIRs
    # to keep pgBackRest happy
    [ -d "${PGDATA}" ] || install -o postgres -g postgres -d -m 0700 "${PGDATA}"
    [ -d "${WALDIR}" ] || install -o postgres -g postgres -d -m 0700 "${WALDIR}"

    if [ "${BOOTSTRAP_FROM_BACKUP}" = "1" ]; then
        log "Attempting restore from backup"
        # we want to override the environment with the environment
        # shellcheck disable=SC2046
        export $(env -i envdir /etc/pgbackrest/bootstrap env) > /dev/null
        export PGBACKREST_REPO1_PATH=

        if [ -z "${PGBACKREST_REPO1_PATH}" ]; then
            log "Unconfigured repository path"
            cat << "__EOT__"

    TimescaleDB Single Helm Chart error:

    You should configure the bootstrapFromBackup in your Helm Chart section by explicitly setting
    the repo1-path to point to the backups.

    For example, if you want to do a disaster recovery, and you want to reuse
    the backup, you could configure the path as follows:

    ```yaml
    bootstrapFromBackup:
      enabled: true
      repo1-path: "/default/timescaledb/"
    ```

    For more information, consult the admin guide:
    https://github.com/timescale/timescaledb-kubernetes/blob/master/charts/timescaledb-single/admin-guide.md#bootstrap-from-backup


    __EOT__

            exit 1
        fi

        log "Listing available backup information"
        pgbackrest info
        EXITCODE=$?
        if [ ${EXITCODE} -ne 0 ]; then
            exit $EXITCODE
        fi

        pgbackrest --log-level-console=detail restore
        EXITCODE=$?
        if [ ${EXITCODE} -eq 0 ]; then
            log "pgBackRest restore finished succesfully, starting instance in recovery"
            # We want to ensure we do not overwrite a current backup repository with archives, therefore
            # we block archiving from succeeding until Patroni can takeover
            touch "${PGDATA}/recovery.signal"
            pg_ctl -D "${PGDATA}" start -o '--archive-command=/bin/false'

            while ! pg_isready -q; do
                log "Waiting for PostgreSQL to become available"
                sleep 3
            done

            # It is not trivial to figure out to what point we should restore, pgBackRest
            # should be fetching WAL segments until the WAL is exhausted. We'll ask pgBackRest
            # what the Maximum Wal is that it currently has; as soon as we see that, we can consider
            # the restore to be done
            while true; do
              MAX_BACKUP_WAL="$(pgbackrest info --output=json | python3 -c "import json,sys;obj=json.load(sys.stdin); print(obj[0]['archive'][0]['max']);")"
              log "Testing whether WAL file ${MAX_BACKUP_WAL} has been restored ..."
              [ -f "${PGDATA}/pg_wal/${MAX_BACKUP_WAL}" ] && break
              sleep 30;
            done

            # At this point we know the final WAL archive has been restored, we should be done.
            log "The WAL file ${MAX_BACKUP_WAL} has been successully restored, shutting down instance"
            pg_ctl -D "${PGDATA}" promote
            pg_ctl -D "${PGDATA}" stop -m fast
            log "Handing over control to Patroni ..."
        else
            log "Bootstrap from backup failed"
            exit 1
        fi
    else
        # Patroni attaches --scope and --datadir to the arguments, we need to strip them off as
        # initdb has no business with these parameters
        initdb_args=""
        for value in "$@"
        do
            case $value in
                "--scope"*)
                    ;;
                "--datadir"*)
                    ;;
                *)
                    initdb_args="${initdb_args} $value"
                    ;;
            esac
        done

        log "Invoking initdb"
        # shellcheck disable=SC2086
        initdb --auth-local=peer --auth-host=md5 --pgdata="${PGDATA}" --waldir="${WALDIR}" ${initdb_args}
    fi

    echo "include_if_exists = '/var/run/postgresql/timescaledb.conf'" >> "${PGDATA}/postgresql.conf"
  post_init.sh: |
    #!/bin/sh
    . "${HOME}/.pod_environment"

    log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - post_init - $1"
    }

    log "Creating extension TimescaleDB in template1 and postgres databases"
    psql -d "$URL" <<__SQL__
      \connect template1
      -- As we're still only initializing, we cannot have synchronous_commit enabled just yet.
      SET synchronous_commit to 'off';
      CREATE EXTENSION timescaledb;

      \connect postgres
      SET synchronous_commit to 'off';
      CREATE EXTENSION timescaledb;
    __SQL__

    TABLESPACES=""
    for tablespace in $TABLESPACES
    do
      log "Creating tablespace ${tablespace}"
      tablespacedir="/var/lib/postgresql/tablespaces/${tablespace}/data"
      psql -d "$URL" --set tablespace="${tablespace}" --set directory="${tablespacedir}" --set ON_ERROR_STOP=1 <<__SQL__
        SET synchronous_commit to 'off';
        CREATE TABLESPACE :"tablespace" LOCATION :'directory';
    __SQL__
    done

    # This directory may contain user defined post init steps
    for file in /etc/timescaledb/post_init.d/*
    do
      [ -d "$file" ] && continue
      [ ! -r "$file" ] && continue

      case "$file" in
        *.sh)
          if [ -x "$file" ]; then
            log "Call post init script [ $file ]"
            "$file" "$@"
            EXITCODE=$?
          else
            log "Source post init script [ $file ]"
            . "$file"
            EXITCODE=$?
          fi
          ;;
        *.sql)
          log "Apply post init sql [ $file ]"
          # Disable synchronous_commit since we're initializing
          PGOPTIONS="-c synchronous_commit=local" psql -d "$URL" -f "$file"
          EXITCODE=$?
          ;;
        *.sql.gz)
          log "Decompress and apply post init sql [ $file ]"
          gunzip -c "$file" | PGOPTIONS="-c synchronous_commit=local" psql -d "$URL"
          EXITCODE=$?
          ;;
        *)
          log "Ignore unknown post init file type [ $file ]"
          EXITCODE=0
          ;;
      esac
        EXITCODE=$?
        if [ "$EXITCODE" != "0" ]
        then
            log "ERROR: post init script $file exited with exitcode $EXITCODE"
            exit $EXITCODE
        fi
    done

    # We exit 0 this script, otherwise the database initialization fails.
    exit 0
  patroni_callback.sh: |
    #!/bin/sh
    set -e

    . "${HOME}/.pod_environment"

    for suffix in "$1" all
    do
      CALLBACK="/etc/timescaledb/callbacks/${suffix}"
      if [ -f "${CALLBACK}" ]
      then
        "${CALLBACK}" "$@"
      fi
    done

  lifecycle_preStop.psql: |
    \pset pager off
    \set ON_ERROR_STOP true
    \set hostname `hostname`
    \set dsn_fmt 'user=postgres host=%s application_name=lifecycle:preStop@%s connect_timeout=5 options=''-c log_min_duration_statement=0'''

    SELECT
        pg_is_in_recovery() AS in_recovery,
        format(:'dsn_fmt', patroni_scope,                       :'hostname') AS primary_dsn,
        format(:'dsn_fmt', '/var/run/postgresql', :'hostname') AS local_dsn
    FROM
        current_setting('cluster_name') AS cs(patroni_scope)
    \gset

    \timing on
    \set ECHO queries

    -- There should be a CHECKPOINT at the primary
    \if :in_recovery
        \connect :"primary_dsn"
        CHECKPOINT;
    \endif

    -- There should also be a CHECKPOINT locally,
    -- for the primary, this may mean we do a double checkpoint,
    -- but the second one would be cheap anyway, so we leave that as is
    \connect :"local_dsn"
    SELECT 'Issuing checkpoint';
    CHECKPOINT;

    \if :in_recovery
        SELECT 'We are a replica: Successfully invoked checkpoints at the primary and locally.';
    \else
        SELECT 'We are a primary: Successfully invoked checkpoints, now issuing a switchover.';
        \! curl -s http://localhost:8008/switchover -XPOST -d '{"leader": "$(hostname)"}'
    \endif
...
---
# Source: timescaledb-single/templates/role-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: timescaledb
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs:
  - create
  - get
  - list
  - patch
  - update
  - watch
  # delete is required only for 'patronictl remove'
  - delete
- apiGroups: [""]
  resources: ["services"]
  verbs:
  - create
- apiGroups: [""]
  resources:
  - endpoints
  - endpoints/restricted
  verbs:
  - create
  - get
  - patch
  - update
  # the following three privileges are necessary only when using endpoints
  - list
  - watch
  # delete is required only for for 'patronictl remove'
  - delete
- apiGroups: [""]
  resources: ["pods"]
  verbs:
  - get
  - list
  - patch
  - update
  - watch
---
# Source: timescaledb-single/templates/rolebinding-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: timescaledb
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: timescaledb
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: timescaledb
---
# Source: timescaledb-single/templates/svc-timescaledb-config.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb-config
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
    component: patroni
spec:
  selector:
    app: timescaledb
    cluster-name: timescaledb
  type: ClusterIP
  clusterIP: None
  ports:
  - name: patroni
    port: 8008
    protocol: TCP
---
# Source: timescaledb-single/templates/svc-timescaledb-replica.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb-replica
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
    component: postgres
    role: replica
spec:
  selector:
    app: timescaledb
    cluster-name: timescaledb
    role: replica
  type: ClusterIP
  ports:
  - name: postgresql
    # This always defaults to 5432, even if `!replicaLoadBalancer.enabled`.
    port: 5432
    targetPort: postgresql
    protocol: TCP
---
# Source: timescaledb-single/templates/svc-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: v1
kind: Service
metadata:
  name: timescaledb
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
    role: master
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "4000"
spec:
  type: LoadBalancer
  ports:
  - name: postgresql
    # This always defaults to 5432, even if `!loadBalancer.enabled`.
    port: 5432
    targetPort: postgresql
    protocol: TCP
---
# Source: timescaledb-single/templates/statefulset-timescaledb.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: timescaledb
  labels:
    app: timescaledb
    chart: timescaledb-single-0.11.0
    release: timescaledb
    heritage: Helm
    cluster-name: timescaledb
spec:
  serviceName: timescaledb
  replicas: 3
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: timescaledb
      release: timescaledb
  template:
    metadata:
      name: timescaledb
      labels:
        app: timescaledb
        release: timescaledb
        cluster-name: timescaledb
    spec:
      serviceAccountName: timescaledb
      securityContext:
        # The postgres user inside the TimescaleDB image has uid=1000.
        # This configuration ensures the permissions of the mounts are suitable
        fsGroup: 1000
        runAsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
      initContainers:
      - name: tstune
        securityContext:
          allowPrivilegeEscalation: false
        image: "timescale/timescaledb-ha:pg13.4-ts2.4.2-p0"
        env:
        - name: TSTUNE_FILE
          value: /var/run/postgresql/timescaledb.conf
        - name: RESOURCES_WAL_VOLUME
          value: 1Gi
        - name: RESOURCES_DATA_VOLUME
          value: 2Gi
        - name: INCLUDE_DIRECTIVE
          value: include_if_exists = '/var/run/postgresql/timescaledb.conf'
        - name: CPUS
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: requests.cpu
              divisor: "1"
        - name: MEMORY
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: requests.memory
              divisor: 1Mi
        - name: RESOURCES_CPU_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: limits.cpu
              divisor: "1"
        - name: RESOURCES_MEMORY_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: timescaledb
              resource: limits.memory
              divisor: 1Mi
        command:
          - sh
          - "-c"
          - |
              set -e
              [ $CPUS -eq 0 ]   && CPUS="${RESOURCES_CPU_LIMIT}"
              [ $MEMORY -eq 0 ] && MEMORY="${RESOURCES_MEMORY_LIMIT}"

              if [ -f "${PGDATA}/postgresql.base.conf" ] && ! grep "${INCLUDE_DIRECTIVE}" postgresql.base.conf -qxF; then
                echo "${INCLUDE_DIRECTIVE}" >> "${PGDATA}/postgresql.base.conf"
              fi

              touch "${TSTUNE_FILE}"
              timescaledb-tune -quiet -pg-version 11 -conf-path "${TSTUNE_FILE}" -cpus "${CPUS}" -memory "${MEMORY}MB" \
                 -yes

              # If there is a dedicated WAL Volume, we want to set max_wal_size to 60% of that volume
              # If there isn't a dedicated WAL Volume, we set it to 20% of the data volume
              if [ "${RESOURCES_WAL_VOLUME}" = "0" ]; then
                WALMAX="${RESOURCES_DATA_VOLUME}"
                WALPERCENT=20
              else
                WALMAX="${RESOURCES_WAL_VOLUME}"
                WALPERCENT=60
              fi

              WALMAX=$(numfmt --from=auto ${WALMAX})

              # Wal segments are 16MB in size, in this way we get a "nice" number of the nearest
              # 16MB
              WALMAX=$(( $WALMAX / 100 * $WALPERCENT / 16777216 * 16 ))
              WALMIN=$(( $WALMAX / 2 ))

              echo "max_wal_size=${WALMAX}MB" >> "${TSTUNE_FILE}"
              echo "min_wal_size=${WALMIN}MB" >> "${TSTUNE_FILE}"
        volumeMounts:
        - name: socket-directory
          mountPath: /var/run/postgresql
        resources:
          {}
      # Issuing the final checkpoints on a busy database may take considerable time.
      # Unfinished checkpoints will require more time during startup, so the tradeoff
      # here is time spent in shutdown/time spent in startup.
      # We choose shutdown here, especially as during the largest part of the shutdown
      # we can still serve clients.
      terminationGracePeriodSeconds: 600
      containers:
      - name: timescaledb
        securityContext:
          allowPrivilegeEscalation: false
        image: "timescale/timescaledb-ha:pg13.4-ts2.4.2-p0"
        imagePullPolicy: Always
        lifecycle:
          preStop:
            exec:
              command:
              - psql
              - -X
              - --file
              - "/etc/timescaledb/scripts/lifecycle_preStop.psql"
        # When reusing an already existing volume it sometimes happens that the permissions
        # of the PGDATA and/or wal directory are incorrect. To guard against this, we always correctly
        # set the permissons of these directories before we hand over to Patroni.
        # We also create all the tablespaces that are defined, to ensure a smooth restore/recovery on a
        # pristine set of Volumes.
        # As PostgreSQL requires to have full control over the permissions of the tablespace directories,
        # we create a subdirectory "data" in every tablespace mountpoint. The full path of every tablespace
        # therefore always ends on "/data".
        # By creating a .pgpass file in the $HOME directory, we expose the superuser password
        # to processes that may not have it in their environment (like the preStop lifecycle hook).
        # To ensure Patroni will not mingle with this file, we give Patroni its own pgpass file.
        # As these files are in the $HOME directory, they are only available to *this* container,
        # and they are ephemeral.
        command:
          - /bin/bash
          - "-c"
          - |
            
            install -o postgres -g postgres -d -m 0700 "/var/lib/postgresql/data" "/var/lib/postgresql/wal/pg_wal" || exit 1
            TABLESPACES=""
            for tablespace in ; do
              install -o postgres -g postgres -d -m 0700 "/var/lib/postgresql/tablespaces/${tablespace}/data"
            done

            # Environment variables can be read by regular users of PostgreSQL. Especially in a Kubernetes
            # context it is likely that some secrets are part of those variables.
            # To ensure we expose as little as possible to the underlying PostgreSQL instance, we have a list
            # of allowed environment variable patterns to retain.
            #
            # We need the KUBERNETES_ environment variables for the native Kubernetes support of Patroni to work.
            #
            # NB: Patroni will remove all PATRONI_.* environment variables before starting PostgreSQL

            # We store the current environment, as initscripts, callbacks, archive_commands etc. may require
            # to have the environment available to them
            set -o posix
            export -p > "${HOME}/.pod_environment"
            export -p | grep PGBACKREST > "${HOME}/.pgbackrest_environment"

            for UNKNOWNVAR in $(env | awk -F '=' '!/^(PATRONI_.*|HOME|PGDATA|PGHOST|LC_.*|LANG|PATH|KUBERNETES_SERVICE_.*)=/ {print $1}')
            do
                unset "${UNKNOWNVAR}"
            done

            touch /var/run/postgresql/timescaledb.conf
            touch /var/run/postgresql/wal_status

            echo "*:*:*:postgres:${PATRONI_SUPERUSER_PASSWORD}" >> ${HOME}/.pgpass
            chmod 0600 ${HOME}/.pgpass

            export PATRONI_POSTGRESQL_PGPASS="${HOME}/.pgpass.patroni"

            exec patroni /etc/timescaledb/patroni.yaml
        env:
        # We use mixed case environment variables for Patroni User management,
        # as the variable themselves are documented to be PATRONI_<username>_OPTIONS.
        # Where possible, we want to have lowercase usernames in PostgreSQL as more complex postgres usernames
        # requiring quoting to be done in certain contexts, which many tools do not do correctly, or even at all.
        # https://patroni.readthedocs.io/en/latest/ENVIRONMENT.html#bootstrap-configuration
        - name: PATRONI_admin_OPTIONS
          value: createrole,createdb
        - name: PATRONI_REPLICATION_USERNAME
          value: standby
        # To specify the PostgreSQL and Rest API connect addresses we need
        # the PATRONI_KUBERNETES_POD_IP to be available as a bash variable, so we can compose an
        # IP:PORT address later on
        - name: PATRONI_KUBERNETES_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: PATRONI_POSTGRESQL_CONNECT_ADDRESS
          value: "$(PATRONI_KUBERNETES_POD_IP):5432"
        - name: PATRONI_RESTAPI_CONNECT_ADDRESS
          value: "$(PATRONI_KUBERNETES_POD_IP):8008"
        - name: PATRONI_KUBERNETES_PORTS
          value: '[{"name": "postgresql", "port": 5432}]'
        - name: PATRONI_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: PATRONI_POSTGRESQL_DATA_DIR
          value: "/var/lib/postgresql/data"
        - name: PATRONI_KUBERNETES_NAMESPACE
          value: default
        - name: PATRONI_KUBERNETES_LABELS
          value: "{app: timescaledb, cluster-name: timescaledb, release: timescaledb}"
        - name: PATRONI_SCOPE
          value: timescaledb
        - name: PGBACKREST_CONFIG
          value: /etc/pgbackrest/pgbackrest.conf
        # PGDATA and PGHOST are not required to let Patroni/PostgreSQL run correctly,
        # but for interactive sessions, callbacks and PostgreSQL tools they should be correct.
        - name: PGDATA
          value: "$(PATRONI_POSTGRESQL_DATA_DIR)"
        - name: PGHOST
          value: "/var/run/postgresql"
        - name: BOOTSTRAP_FROM_BACKUP
          value: "0"
          # pgBackRest is also called using the archive_command if the backup is enabled.
          # this script will also need access to the environment variables specified for
          # the backup. This can be removed once we do not directly invoke pgBackRest
          # from inside the TimescaleDB container anymore
        envFrom:
        - secretRef:
            name: timescaledb-credentials
            optional: false
        - secretRef:
            name: timescaledb-pgbackrest
            optional: true
        ports:
        - containerPort: 8008
          name: patroni
        - containerPort: 5432
          name: postgresql
        readinessProbe:
          exec:
            command:
              - pg_isready
              - -h
              - /var/run/postgresql
          initialDelaySeconds: 5
          periodSeconds: 30
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 6
        volumeMounts:
        - name: storage-volume
          mountPath: "/var/lib/postgresql"
          subPath: ""
        - name: wal-volume
          mountPath: "/var/lib/postgresql/wal"
          subPath: ""
        - mountPath: /etc/timescaledb/patroni.yaml
          subPath: patroni.yaml
          name: patroni-config
          readOnly: true
        - mountPath: /etc/timescaledb/scripts
          name: timescaledb-scripts
          readOnly: true
        - mountPath: /etc/timescaledb/post_init.d
          name: post-init
          readOnly: true
        - mountPath: /etc/certificate
          name: certificate
          readOnly: true
        - name: socket-directory
          mountPath: /var/run/postgresql
        
        - mountPath: /etc/pgbackrest
          name: pgbackrest
          readOnly: true
        - mountPath: /etc/pgbackrest/bootstrap
          name: pgbackrest-bootstrap
          readOnly: true
        resources:
          {}
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: "kubernetes.io/hostname"
              labelSelector:
                matchLabels:
                  app: timescaledb
                  release: "timescaledb"
                  cluster-name: timescaledb
          - weight: 50
            podAffinityTerm:
              topologyKey: failure-domain.beta.kubernetes.io/zone
              labelSelector:
                matchLabels:
                  app: timescaledb
                  release: "timescaledb"
                  cluster-name: timescaledb
        
      volumes:
      - name: socket-directory
        emptyDir: {}
      - name: patroni-config
        configMap:
          name: timescaledb-patroni
      - name: timescaledb-scripts
        configMap:
          name: timescaledb-scripts
          defaultMode: 488 # 0750 permissions
      
      - name: post-init
        projected:
          defaultMode: 0750
          sources:
            - configMap:
                name: custom-init-scripts
                optional: true
            - secret:
                name: custom-secret-scripts
                optional: true
      - name: pgbouncer
        configMap:
          name: timescaledb-pgbouncer
          defaultMode: 416 # 0640 permissions
          optional: true
      - name: pgbackrest
        configMap:
          name: timescaledb-pgbackrest
          defaultMode: 416 # 0640 permissions
          optional: true
      - name: certificate
        secret:
          secretName:  timescaledb-certificate
          defaultMode: 416 # 0640 permissions
      - name: pgbackrest-bootstrap
        secret:
          secretName: pgbackrest-bootstrap
          optional: True
  volumeClaimTemplates:
    - metadata:
        name: storage-volume
        annotations:
        labels:
          app: timescaledb
          release: timescaledb
          heritage: Helm
          cluster-name: timescaledb
          purpose: data-directory
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: "2Gi"
    - metadata:
        name: wal-volume
        annotations:
        labels:
          app: timescaledb
          release: timescaledb
          heritage: Helm
          cluster-name: timescaledb
          purpose: wal-directory
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: "1Gi"
---
# Source: timescaledb-single/templates/configmap-pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: timescaledb-single/templates/configmap-pgbouncer.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: timescaledb-single/templates/pgbackrest.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
---
# Source: timescaledb-single/templates/svc-prometheus.yaml
# This file and its contents are licensed under the Apache License 2.0.
# Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
#
# This service is only created if Prometheus is enabled.

NOTES:
TimescaleDB can be accessed via port 5432 on the following DNS name from within your cluster:
timescaledb.default.svc.cluster.local

To get your password for superuser run:

    # superuser password
    PGPASSWORD_POSTGRES=$(kubectl get secret --namespace default timescaledb-credentials -o jsonpath="{.data.PATRONI_SUPERUSER_PASSWORD}" | base64 --decode)

    # admin password
    PGPASSWORD_ADMIN=$(kubectl get secret --namespace default timescaledb-credentials -o jsonpath="{.data.PATRONI_admin_PASSWORD}" | base64 --decode)

To connect to your database, chose one of these options:

1. Run a postgres pod and connect using the psql cli:
    # login as superuser
    kubectl run -i --tty --rm psql --image=postgres \
      --env "PGPASSWORD=$PGPASSWORD_POSTGRES" \
      --command -- psql -U postgres \
      -h timescaledb.default.svc.cluster.local postgres

    # login as admin
    kubectl run -i --tty --rm psql --image=postgres \
      --env "PGPASSWORD=$PGPASSWORD_ADMIN" \
      --command -- psql -U admin \
      -h timescaledb.default.svc.cluster.local postgres

2. Directly execute a psql session on the master node

   MASTERPOD="$(kubectl get pod -o name --namespace default -l release=timescaledb,role=master)"
   kubectl exec -i --tty --namespace default ${MASTERPOD} -- psql -U postgres
